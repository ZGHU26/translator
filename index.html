<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ğŸ‡«ğŸ‡· æ³•è¯­è¯¾å ‚åŒå£°ä¼ è¯‘ (Pro MAXï¼šæ®µè½/é˜Ÿåˆ—/å»é‡/æŠ¢æ•‘interim/å¯æ¢å¤/ä¸ä¹±æ»š/è‡ªåŠ¨ç»­ç¿»è¯‘)</title>
  <style>
    :root{
      --primary:#2c3e50;
      --accent:#2980b9;
      --bg:#f4f6f9;
      --card:#ffffff;
      --success:#27ae60;
      --danger:#e74c3c;
      --muted:#7f8c8d;
    }
    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif;
      background:var(--bg); margin:0; padding:0;
      display:flex; flex-direction:column; height:100vh; overflow:hidden;
    }
    header{
      background:var(--card);
      padding:12px 20px;
      box-shadow:0 2px 10px rgba(0,0,0,.05);
      z-index:100; flex-shrink:0;
      border-bottom:1px solid #e1e4e8;
    }
    .header-row{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      flex-wrap:wrap; margin-bottom:8px;
    }
    .header-row:last-child{ margin-bottom:0; }

    input, textarea{
      padding:8px 12px; border:1px solid #dfe6e9; border-radius:6px; outline:none;
      font-size:14px; background:#fafafa; transition:.2s;
      box-sizing:border-box;
    }
    input:focus, textarea:focus{ border-color:var(--accent); background:white; }

    .lang-switch{ display:flex; background:#ecf0f1; border-radius:6px; padding:2px; }
    .lang-btn{
      padding:6px 12px; border:none; background:transparent; cursor:pointer;
      font-size:13px; font-weight:700; color:#7f8c8d; border-radius:4px;
    }
    .lang-btn.active{ background:white; color:var(--accent); box-shadow:0 1px 3px rgba(0,0,0,.1); }

    .btn-action{
      padding:8px 16px; border:none; border-radius:6px;
      font-weight:800; cursor:pointer; color:white; transition:.2s;
      font-size:14px; display:flex; align-items:center; gap:6px;
    }
    .btn-action:active{ transform:translateY(1px); }
    .btn-action:hover{ opacity:.92; }
    #btn-start{ background:var(--success); }
    #btn-stop{ background:var(--danger); display:none; }
    #btn-export{ background:var(--accent); }
    #btn-clear{ background:#95a5a6; }
    #btn-glossary{ background:#8e44ad; }

    #restore-bar{
      background:#fff3cd; color:#856404;
      padding:10px; text-align:center; font-size:14px;
      display:none; cursor:pointer; border-bottom:1px solid #ffeeba;
    }

    #container{
      flex:1; overflow-y:auto; padding:20px;
      padding-bottom:230px;
      max-width:960px; margin:0 auto; width:100%; box-sizing:border-box;
    }

    .note-block{
      background:var(--card); border-radius:12px;
      box-shadow:0 4px 15px rgba(0,0,0,.03);
      margin-bottom:22px; overflow:hidden; border:1px solid #edf2f7;
      animation:slideIn .22s ease;
    }
    @keyframes slideIn{ from{opacity:0; transform:translateY(14px);} to{opacity:1; transform:translateY(0);} }

    .note-header{
      padding:8px 15px; background:#fafbfc; border-bottom:1px solid #f0f0f0;
      display:flex; justify-content:space-between; align-items:center;
      font-size:12px; color:#95a5a6;
    }
    .status-tag{ font-weight:900; }

    .content-row{ padding:15px; display:flex; flex-direction:column; gap:12px; }

    .text-origin{
      font-family:Georgia, serif; font-size:14px; color:#7f8c8d; line-height:1.55;
      background:#f8f9fa; padding:10px; border-radius:8px;
      border-left:3px solid #cbd5e0;
      white-space:pre-wrap; word-break:break-word;
    }
    .text-trans{
      font-size:16px; color:#2c3e50; line-height:1.85; font-weight:500;
      padding:0 5px; text-align:justify;
      white-space:pre-wrap; word-break:break-word;
    }
    .text-trans b{ color:#d35400; background:rgba(241,196,15,.12); padding:0 2px; border-radius:3px; }

    .tool-bar{ display:flex; justify-content:flex-end; gap:10px; margin-top:6px; }
    .mini-btn{
      font-size:11px; color:#95a5a6; background:white; border:1px solid #e1e4e8;
      padding:4px 9px; border-radius:4px; cursor:pointer;
      user-select:none;
    }
    .mini-btn:hover{ border-color:var(--accent); color:var(--accent); }

    #bottom-bar{
      position:fixed; bottom:0; left:0; width:100%;
      background:rgba(255,255,255,.98);
      border-top:1px solid #eee; padding:12px 20px;
      box-shadow:0 -5px 20px rgba(0,0,0,.05);
      z-index:900; backdrop-filter:blur(10px);
      transition:transform .3s;
    }
    #bottom-bar.hidden{ transform:translateY(120%); }

    .status-line{ display:flex; justify-content:space-between; font-size:12px; color:#7f8c8d; margin-bottom:6px; }
    .live-preview{
      height:70px; overflow-y:auto; color:#34495e; font-size:14px;
      background:#f1f2f6; border-radius:6px; padding:10px; border:1px solid #eee;
      white-space:pre-wrap; word-break:break-word;
    }
    .rec-dot{
      width:10px; height:10px; background:red; border-radius:50%;
      display:inline-block; margin-right:6px; animation:pulse 1.5s infinite;
    }
    @keyframes pulse{ 0%{opacity:1} 50%{opacity:.35} 100%{opacity:1} }

    #scroll-btn{
      position:fixed; bottom:190px; right:30px;
      background:var(--accent); color:white;
      width:42px; height:42px; border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      box-shadow:0 4px 12px rgba(41,128,185,.3);
      cursor:pointer; z-index:800;
      opacity:0; transition:.25s; pointer-events:none; font-weight:900;
      user-select:none;
    }
    #scroll-btn.show{ opacity:1; pointer-events:auto; }
    #scroll-badge{
      position:absolute; top:-5px; right:-5px;
      background:var(--danger); width:10px; height:10px; border-radius:50%;
      display:none;
    }

    /* æœ¯è¯­è¡¨æŠ˜å åŒº */
    #glossary-panel{
      display:none;
      margin-top:10px;
      padding:12px;
      background:#fbf6ff;
      border:1px solid #eadcf6;
      border-radius:10px;
    }
    #glossary-panel h4{ margin:0 0 8px 0; color:#5d3b7a; font-size:13px; }
    #glossary{
      width:100%;
      min-height:84px;
      resize:vertical;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      background:#fff;
    }
    .glossary-row{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      margin-top:8px; color:#5d3b7a; font-size:12px;
    }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      background:#efe5fb; border:1px solid #e3d2fb;
      padding:6px 10px; border-radius:999px;
    }
    .hint{
      color:#8c6aa8;
      font-size:12px;
    }

    @media (max-width:768px){
      .header-row{ flex-direction:column; align-items:stretch; }
      #container{ padding:10px; padding-bottom:240px; }
      .btn-action{ justify-content:center; }
      #scroll-btn{ right:16px; }
    }
  </style>
</head>
<body>

<div id="restore-bar">âš ï¸ æ£€æµ‹åˆ°ä¸Šæ¬¡è¯¾ç¨‹å†…å®¹ï¼Œç‚¹è¿™é‡Œæ¢å¤</div>

<header>
  <div class="header-row">
    <div style="font-weight:900;color:var(--primary);display:flex;align-items:center;gap:10px;">
      ğŸ“ åŒå£°ä¼ è¯‘ Pro MAX
      <div class="lang-switch">
        <button class="lang-btn active" id="btn-fr">FR æ³•è¯­</button>
        <button class="lang-btn" id="btn-en">EN è‹±è¯­</button>
      </div>
    </div>
    <div style="display:flex;gap:10px;flex:1;justify-content:flex-end;flex-wrap:wrap;">
      <input type="password" id="api-key" placeholder="ç²˜è´´ DeepSeek API Key" style="width:240px;">
    </div>
  </div>

  <div class="header-row" style="margin-top:10px;">
    <input type="text" id="topic-input" placeholder="è¾“å…¥è¯¾ç¨‹ä¸»é¢˜ï¼ˆä¾‹å¦‚: Droit civil / SIG / MobilitÃ©ï¼‰" style="flex:1;">
    <button id="btn-glossary" class="btn-action">ğŸ“š æœ¯è¯­è¡¨</button>
    <button id="btn-start" class="btn-action">ğŸ™ï¸ ä¸Šè¯¾</button>
    <button id="btn-stop" class="btn-action">â¹ ä¸‹è¯¾</button>
    <button id="btn-export" class="btn-action">ğŸ’¾ å¯¼å‡º Word</button>
    <button id="btn-clear" class="btn-action" style="font-size:12px;padding:8px 12px;">ğŸ—‘ï¸ æ¸…ç©º</button>
  </div>

  <div id="glossary-panel">
    <h4>å¯é€‰æœ¯è¯­è¡¨ï¼ˆæ¯è¡Œä¸€æ¡ï¼‰ï¼š<span style="color:#8e44ad;">æœ¯è¯­=ä¸­æ–‡è§£é‡Š</span>ï¼ˆåªå¡«å¸¸ç”¨ 10~30 æ¡å°±å¤Ÿï¼‰</h4>
    <textarea id="glossary" placeholder="EPCI=å¸‚é•‡é—´å…¬å…±åˆä½œæœºæ„
amÃ©nagement=è§„åˆ’
mobilitÃ©=å‡ºè¡Œ/æµåŠ¨æ€§
tramway=æœ‰è½¨ç”µè½¦"></textarea>
    <div class="glossary-row">
      <span class="pill">
        <input type="checkbox" id="auto-terms" checked />
        <label for="auto-terms" style="cursor:pointer;">è‡ªåŠ¨ä»ç¿»è¯‘é‡Œæå–æ–°æœ¯è¯­å¹¶è®°å¿†</label>
      </span>
      <span class="pill">
        <input type="checkbox" id="paragraph-mode" checked />
        <label for="paragraph-mode" style="cursor:pointer;">æ®µè½æ¨¡å¼ï¼ˆå…ˆæ”’ä¸€æ®µå†ç¿»è¯‘ï¼‰</label>
      </span>
      <span class="pill">
        <button class="mini-btn" id="btn-save-glossary">ä¿å­˜æœ¯è¯­è¡¨</button>
        <button class="mini-btn" id="btn-clear-glossary">æ¸…ç©ºæœ¯è¯­è¡¨</button>
      </span>
      <span class="hint">æç¤ºï¼šæœ¯è¯­è¡¨å­˜æœ¬æœº localStorageï¼Œä¸ä¸Šä¼ ã€‚401 ä¿®å¥½ Key ä¼šè‡ªåŠ¨ç»­ç¿»è¯‘ã€‚</span>
    </div>
  </div>
</header>

<div id="container">
  <div style="text-align:center;color:#bdc3c7;margin-top:80px;" id="welcome-msg">
    <h3>ğŸ‘‹ å‡†å¤‡å°±ç»ª</h3>
    <p>è¾“å…¥è¯¾ç¨‹ä¸»é¢˜ï¼Œç‚¹â€œä¸Šè¯¾â€å¼€å§‹è®°å½•</p>
    <p style="font-size:12px;">âœ… é˜Ÿåˆ—ä¸ä¹±åº Â· âœ… æ–­çº¿æ¢å¤ Â· âœ… æ®µè½è¾“å‡º Â· âœ… æŠ¢æ•‘ interim é˜²è¦†ç›– Â· âœ… ä¸ä¹±æ»šåŠ¨</p>
  </div>
</div>

<div id="scroll-btn">â¬‡<div id="scroll-badge"></div></div>

<div id="bottom-bar" class="hidden">
  <div class="status-line">
    <span id="status-text"><span class="rec-dot"></span>æ­£åœ¨è†å¬è€å¸ˆå‘è¨€â€¦</span>
    <span id="char-count">ç¼“å†²åŒº: 0å­—</span>
  </div>
  <div class="live-preview" id="live-text"></div>
</div>

<script>
/**
 * âš ï¸ corsproxy.io æ˜¯ç¬¬ä¸‰æ–¹ä»£ç†ï¼ˆä¸ç¨³å®š/ä¸å®‰å…¨ï¼‰ã€‚
 * çœŸé•¿æœŸç”¨ï¼šå»ºè®®è‡ªå»ºè½¬å‘ï¼ˆCloudflare Worker/Vercel/Nodeï¼‰ï¼Œå†æŠŠ CONFIG.url æ”¹æˆä½ çš„è½¬å‘åœ°å€ã€‚
 */
const CONFIG = {
  url: "https://corsproxy.io/?https://api.deepseek.com/chat/completions",
  model: "deepseek-chat",

  // æ®µè½ç­–ç•¥
  minCharsToSend: 150,
  maxCharsForce: 1100,
  silenceThreshold: 3800,
  punctuationWait: 1100,
  forceFlushMs: 6500,

  localStorageKey: "classroom_trans_backup_v3",
  glossaryKey: "classroom_glossary_v1"
};

let state = {
  recording: false,
  buffer: "",
  interim: "",
  timer: null,
  lang: "fr-FR",
  recognition: null,
  userScrolled: false,
  noteHistory: []
};

const UI = {
  container: document.getElementById("container"),
  liveText: document.getElementById("live-text"),
  status: document.getElementById("status-text"),
  count: document.getElementById("char-count"),
  restoreBar: document.getElementById("restore-bar"),
  welcome: document.getElementById("welcome-msg"),
  bottomBar: document.getElementById("bottom-bar"),
  scrollBtn: document.getElementById("scroll-btn"),
  scrollBadge: document.getElementById("scroll-badge"),

  glossaryPanel: document.getElementById("glossary-panel"),
  glossary: document.getElementById("glossary"),
  autoTerms: document.getElementById("auto-terms"),
  paragraphMode: document.getElementById("paragraph-mode"),

  apiKey: document.getElementById("api-key"),
  topic: document.getElementById("topic-input"),

  btnFr: document.getElementById("btn-fr"),
  btnEn: document.getElementById("btn-en"),
  btnGlossary: document.getElementById("btn-glossary"),
  btnStart: document.getElementById("btn-start"),
  btnStop: document.getElementById("btn-stop"),
  btnExport: document.getElementById("btn-export"),
  btnClear: document.getElementById("btn-clear"),
  btnSaveGlossary: document.getElementById("btn-save-glossary"),
  btnClearGlossary: document.getElementById("btn-clear-glossary"),
};

// ====== ç¿»è¯‘é˜Ÿåˆ—ï¼ˆä¸²è¡Œã€ä¸ä¹±åºï¼‰======
const TRANSLATE = {
  queue: [],
  running: false,
  seq: 0,
  recentTranslations: [],
  maxRecent: 12,
  lastFinalTail: "",
  pausedByAuth: false
};

// ====== æŠ¢æ•‘ interim ======
let lastInterim = "";
let lastInterimAt = 0;
let interimCommitTimer = null;
const INTERIM_STABLE_MS = 700;
const INTERIM_MIN_CHARS = 12;

let lastBufferUpdateAt = Date.now();

// ====== è¯†åˆ«é‡å¯é™é¢‘/é€€é¿ï¼ˆé˜²æ­¢ç–¯ç‹‚å¼¹æƒé™/ç–¯ç‹‚é‡å¯ï¼‰=====
let lastRecStartAt = 0;
let recRestartCooldown = 800;

// ====== Wake Lockï¼ˆå°½é‡é˜²æ­¢é¡µé¢ä¼‘çœ ï¼‰=====
let wakeLock = null;

function bindUI(){
  UI.btnGlossary.addEventListener("click", toggleGlossary);

  UI.btnFr.addEventListener("click", () => setLang("fr"));
  UI.btnEn.addEventListener("click", () => setLang("en"));

  UI.btnStart.addEventListener("click", startSession);
  UI.btnStop.addEventListener("click", stopSession);
  UI.btnExport.addEventListener("click", exportWord);
  UI.btnClear.addEventListener("click", clearSession);

  UI.btnSaveGlossary.addEventListener("click", saveGlossary);
  UI.btnClearGlossary.addEventListener("click", clearGlossary);

  UI.restoreBar.addEventListener("click", restoreSession);
  UI.scrollBtn.addEventListener("click", scrollToBottomForce);

  // ä¿®å¥½ API Key åè‡ªåŠ¨ç»­ç¿»è¯‘
  UI.apiKey.addEventListener("input", () => {
    const k = UI.apiKey.value.trim();
    if (k.length > 10 && TRANSLATE.pausedByAuth) {
      TRANSLATE.pausedByAuth = false;
      if (!TRANSLATE.running && TRANSLATE.queue.length) runTranslateQueue();
    }
  });

  UI.container.addEventListener("scroll", () => {
    const dist = UI.container.scrollHeight - UI.container.scrollTop - UI.container.clientHeight;
    state.userScrolled = dist > 140;
    updateScrollBtn();
  });

  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
      // å›åˆ°å‰å°ï¼šå°è¯•é‡å¯è¯†åˆ«
      if (state.recording) safeRestartRecognition("visibilitychange");
      // æ¢å¤ wakelock
      if (state.recording) enableWakeLock();
    } else {
      // åå°æ—¶é‡Šæ”¾ wakelockï¼ˆæµè§ˆå™¨ä¸€èˆ¬ä¹Ÿä¼šé‡Šæ”¾ï¼‰
      // ä¸å¼ºæ±‚
    }
  });

  window.addEventListener("focus", () => {
    if (state.recording) safeRestartRecognition("focus");
  });

  window.onbeforeunload = () => {
    saveToLocal();
    localStorage.setItem(CONFIG.glossaryKey, UI.glossary.value || "");
  };
}

window.onload = () => {
  bindUI();

  // æ¢å¤ API Key/æœ¯è¯­è¡¨
  const key = localStorage.getItem("ds_api_key");
  if (key) UI.apiKey.value = key;

  const g = localStorage.getItem(CONFIG.glossaryKey);
  if (g) UI.glossary.value = g;

  // æ£€æŸ¥æ˜¯å¦æœ‰å¤‡ä»½
  const backup = localStorage.getItem(CONFIG.localStorageKey);
  if (backup) {
    try {
      const data = JSON.parse(backup);
      if (Array.isArray(data) && data.length > 0) {
        UI.restoreBar.style.display = "block";
        UI.welcome.style.display = "none";
      }
    } catch {}
  }

  // favicon 404 ä¸å½±å“åŠŸèƒ½
};

// ===== UIï¼šæ»šåŠ¨é”å®š =====
function updateScrollBtn(){
  UI.scrollBtn.classList.toggle("show", state.userScrolled);
  if (!state.userScrolled) UI.scrollBadge.style.display = "none";
}
function scrollToBottomForce(){
  UI.container.scrollTop = UI.container.scrollHeight;
  state.userScrolled = false;
  updateScrollBtn();
}
function smartScroll(){
  if (!state.userScrolled) UI.container.scrollTop = UI.container.scrollHeight;
  else UI.scrollBadge.style.display = "block";
}

// ===== æœ¯è¯­è¡¨ =====
function toggleGlossary(){
  UI.glossaryPanel.style.display = (UI.glossaryPanel.style.display === "block") ? "none" : "block";
}
function saveGlossary(){
  localStorage.setItem(CONFIG.glossaryKey, UI.glossary.value || "");
  alert("âœ… æœ¯è¯­è¡¨å·²ä¿å­˜ï¼ˆæœ¬æœº localStorageï¼‰");
}
function clearGlossary(){
  if (!confirm("ç¡®å®šæ¸…ç©ºæœ¯è¯­è¡¨ï¼Ÿ")) return;
  UI.glossary.value = "";
  localStorage.removeItem(CONFIG.glossaryKey);
}
function parseGlossary(){
  const text = (UI.glossary.value || "").trim();
  if (!text) return [];
  const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  const pairs = [];
  for (const line of lines) {
    const idx = line.indexOf("=");
    if (idx > 0) {
      const k = line.slice(0, idx).trim();
      const v = line.slice(idx + 1).trim();
      if (k && v) pairs.push([k, v]);
    }
  }
  return pairs;
}
function glossaryToPromptBlock(){
  const pairs = parseGlossary();
  if (!pairs.length) return "";
  return pairs.map(([k,v]) => `${k}=${v}`).join("\n");
}

// ===== è¯­è¨€åˆ‡æ¢ =====
function setLang(l){
  document.querySelectorAll(".lang-btn").forEach(b => b.classList.remove("active"));
  if (l === "fr") UI.btnFr.classList.add("active");
  else UI.btnEn.classList.add("active");

  state.lang = (l === "fr") ? "fr-FR" : "en-US";
  if (state.recording) {
    try { state.recognition && state.recognition.stop(); } catch {}
  }
}

// ===== å…³é”®ï¼šå…ˆèµ°ä¸€æ¬¡ getUserMediaï¼Œé¿å…åå¤å¼¹æƒé™ =====
async function ensureMicPermission(){
  if (!navigator.mediaDevices?.getUserMedia) {
    alert("âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£è®¿é—®ï¼Œè¯·ç”¨ Chromeã€‚");
    return false;
  }

  // å¦‚æœæƒé™è¢«æ‹’ç»ï¼Œç›´æ¥æç¤º
  if (navigator.permissions?.query) {
    try {
      const st = await navigator.permissions.query({ name: "microphone" });
      if (st.state === "denied") {
        alert("éº¦å…‹é£æƒé™è¢«æ‹’ç»ï¼šè¯·ç‚¹åœ°å€æ å·¦è¾¹ğŸ”’/i â†’ Site settings â†’ Microphone â†’ Allow");
        return false;
      }
    } catch {}
  }

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(t => t.stop()); // åªä¸ºæ‹¿æƒé™
    return true;
  } catch {
    alert("æ— æ³•è·å–éº¦å…‹é£æƒé™ï¼Œè¯·æ£€æŸ¥ç³»ç»Ÿ/æµè§ˆå™¨éº¦å…‹é£è®¾ç½®ã€‚");
    return false;
  }
}

// ===== Wake Lockï¼ˆå°½é‡ä¿æŒä¸ç¡çœ ï¼‰=====
async function enableWakeLock(){
  try{
    if ("wakeLock" in navigator) {
      if (wakeLock) return;
      wakeLock = await navigator.wakeLock.request("screen");
      wakeLock.addEventListener("release", () => { wakeLock = null; });
    }
  } catch {}
}
function disableWakeLock(){
  try{ wakeLock && wakeLock.release(); } catch {}
  wakeLock = null;
}

// ===== SpeechRecognition åˆå§‹åŒ– =====
function initSpeech(){
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert("âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ï¼Œè¯·ç”¨ Chromeã€‚");
    return false;
  }

  const rec = new SpeechRecognition();
  rec.lang = state.lang;
  rec.continuous = true;
  rec.interimResults = true;

  rec.onstart = () => {
    state.recording = true;
    updateUiState(true);
    UI.status.innerHTML = `<span class="rec-dot"></span>æ­£åœ¨è†å¬è€å¸ˆå‘è¨€â€¦`;
    lastRecStartAt = Date.now();
    recRestartCooldown = 800;
  };

  rec.onend = () => {
    if (state.recording) safeRestartRecognition("onend");
  };

  rec.onerror = (e) => {
    console.warn("Speech error:", e.error);
    // è¿™å‡ ä¸ªé”™è¯¯ä¸è¦ç–¯ç‹‚é‡å¯ï¼Œå¦åˆ™å®¹æ˜“åå¤å¼¹
    if (e.error === "not-allowed" || e.error === "service-not-allowed") {
      alert("âŒ æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®ã€‚");
      state.recording = false;
      updateUiState(false);
      return;
    }
    // å…¶ä»–é”™è¯¯ï¼Œäº¤ç»™ safeRestartRecognition åšé€€é¿é‡å¯
  };

  rec.onresult = (event) => {
    let newFinal = "";
    let newInterim = "";

    for (let i = event.resultIndex; i < event.results.length; i++){
      if (event.results[i].isFinal) newFinal += event.results[i][0].transcript;
      else newInterim += event.results[i][0].transcript;
    }

    if (newFinal) {
      const cleaned = dedupeFinalAppend(newFinal);
      if (cleaned) {
        state.buffer += cleaned + " ";
        lastBufferUpdateAt = Date.now();
        analyzeAndScheduleSend();
      }
    }

    state.interim = newInterim;
    scheduleInterimRescue(newInterim);
    updateLivePreview();
  };

  state.recognition = rec;
  return true;
}

// ===== è¯†åˆ«é‡å¯ï¼šé™é¢‘ + æŒ‡æ•°é€€é¿ =====
function safeRestartRecognition(reason){
  if (!state.recording || !state.recognition) return;

  const now = Date.now();
  if (now - lastRecStartAt < recRestartCooldown) return;

  try{
    state.recognition.lang = state.lang;
    state.recognition.start();
    lastRecStartAt = now;
    recRestartCooldown = 800;
  } catch {
    recRestartCooldown = Math.min(6000, Math.floor(recRestartCooldown * 1.6));
    setTimeout(() => {
      if (!state.recording) return;
      try{
        state.recognition.start();
        lastRecStartAt = Date.now();
      } catch {}
    }, recRestartCooldown);
  }
}

// ===== final å»é‡ =====
function dedupeFinalAppend(finalText){
  const t = (finalText || "").trim();
  if (!t) return "";
  const tail = t.slice(-40);
  if (tail && TRANSLATE.lastFinalTail && tail === TRANSLATE.lastFinalTail) return "";
  TRANSLATE.lastFinalTail = tail;
  return t;
}

// ===== interim æŠ¢æ•‘ =====
function scheduleInterimRescue(interimText){
  const now = Date.now();
  const t = (interimText || "").trim();

  if (t !== lastInterim) {
    lastInterim = t;
    lastInterimAt = now;
  }

  if (interimCommitTimer) clearTimeout(interimCommitTimer);
  interimCommitTimer = setTimeout(() => {
    const stableFor = Date.now() - lastInterimAt;
    if (stableFor >= INTERIM_STABLE_MS) {
      commitStableInterim();
      updateLivePreview();
    }
  }, INTERIM_STABLE_MS + 20);
}

function commitStableInterim(){
  if (!lastInterim) return;
  const t = lastInterim.trim();
  if (t.length < INTERIM_MIN_CHARS) return;

  const cut = Math.max(
    t.lastIndexOf(" "),
    t.lastIndexOf("."), t.lastIndexOf("?"), t.lastIndexOf("!"),
    t.lastIndexOf("ã€‚"), t.lastIndexOf("ï¼Ÿ"), t.lastIndexOf("ï¼"),
    t.lastIndexOf(","), t.lastIndexOf("ï¼Œ"),
    t.lastIndexOf(";"), t.lastIndexOf("ï¼›"),
    t.lastIndexOf(":"), t.lastIndexOf("ï¼š")
  );
  if (cut < 0) return;

  const safeChunk = t.slice(0, cut + 1).trim();
  if (!safeChunk) return;

  const buf = state.buffer.trim();
  if (buf.endsWith(safeChunk)) return;

  state.buffer += safeChunk + " ";
  lastBufferUpdateAt = Date.now();
  analyzeAndScheduleSend();
}

// ===== å®æ—¶é¢„è§ˆ =====
function updateLivePreview(){
  UI.liveText.innerHTML = `
    <span style="color:#2c3e50;font-weight:800;">${escapeHtml(state.buffer)}</span>
    <span style="color:#95a5a6;">${escapeHtml(state.interim)}</span>
  `;
  UI.liveText.scrollTop = UI.liveText.scrollHeight;
  UI.count.innerText = `ç¼“å†²åŒº: ${(state.buffer.length + state.interim.length)}å­—`;
}

// ===== æ®µè½/å‘åŒ…ç­–ç•¥ =====
function analyzeAndScheduleSend(){
  if (state.timer) clearTimeout(state.timer);

  const text = state.buffer.trim();
  if (!text) return;

  const paragraphMode = UI.paragraphMode.checked;
  const lastChar = text.slice(-1);
  const isPunc = /[.?!ã€‚ï¼Ÿï¼]/.test(lastChar);

  if (text.length > CONFIG.maxCharsForce) {
    flushBuffer("å¼ºåˆ¶å‘é€(è¿‡é•¿)");
    return;
  }

  if (paragraphMode) {
    if (isPunc && text.length >= CONFIG.minCharsToSend) {
      state.timer = setTimeout(() => flushBuffer("æ®µè½å®Œæˆ(æ ‡ç‚¹)"), CONFIG.punctuationWait);
    } else {
      state.timer = setTimeout(() => flushBuffer("æ®µè½ç­‰å¾…(åœé¡¿)"), CONFIG.silenceThreshold);
    }
  } else {
    const fastMin = 60;
    state.timer = setTimeout(() => flushBuffer("å®æ—¶æ¨¡å¼(åœé¡¿)"), text.length >= fastMin ? 1200 : 1800);
  }

  setTimeout(() => {
    if (!state.recording) return;
    const idle = Date.now() - lastBufferUpdateAt;
    if (idle >= CONFIG.forceFlushMs && state.buffer.trim().length > 0) {
      flushBuffer("æœ€å¤§æ—¶é—´çª—åˆ‡æ®µ");
    }
  }, CONFIG.forceFlushMs + 50);
}

// ===== å…¥é˜Ÿ =====
async function flushBuffer(reason){
  const text = state.buffer.trim();
  if (!text) return;

  const textToSend = text;
  state.buffer = "";
  state.interim = "";
  lastInterim = "";
  updateLivePreview();

  const blockId = "note-" + Date.now();
  const time = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});

  const noteData = { id:blockId, raw:textToSend, trans:"â³ æ­£åœ¨ç¿»è¯‘â€¦", time, status:"pending" };
  state.noteHistory.push(noteData);
  saveToLocal();

  renderNoteBlock(noteData);
  smartScroll();

  TRANSLATE.queue.push({
    seq: ++TRANSLATE.seq,
    blockId,
    raw: textToSend,
    topic: UI.topic.value || "é€šç”¨å­¦æœ¯",
    reason: reason || ""
  });

  runTranslateQueue();
}

// ===== é˜Ÿåˆ—ç¿»è¯‘ï¼ˆä¸²è¡Œï¼‰=====
async function runTranslateQueue(){
  if (TRANSLATE.running || TRANSLATE.pausedByAuth) return;
  TRANSLATE.running = true;

  while (TRANSLATE.queue.length && !TRANSLATE.pausedByAuth) {
    const job = TRANSLATE.queue.shift();
    await translateOne(job);
  }

  TRANSLATE.running = false;
  UI.status.innerHTML = state.recording
    ? `<span class="rec-dot"></span>æ­£åœ¨è†å¬è€å¸ˆå‘è¨€â€¦`
    : `âœ… å·²åœæ­¢ï¼ˆç¿»è¯‘å®Œæˆï¼‰`;
}

function buildContext(){
  return TRANSLATE.recentTranslations.slice(-TRANSLATE.maxRecent).join("\n");
}

async function translateOne(job){
  const apiKey = (UI.apiKey.value || "").trim();
  if (!apiKey) {
    updateNote(job.blockId, "âš ï¸ ç¼ºå°‘ API Key", true);
    return;
  }
  localStorage.setItem("ds_api_key", apiKey);

  UI.status.innerText = `ğŸš€ ç¿»è¯‘ä¸­... (#${job.seq})`;

  const glossaryBlock = glossaryToPromptBlock();
  const ctx = buildContext();

  const systemPrompt = `
ä½ æ˜¯ä¸€åä¸“ä¸šè¯¾å ‚åŒå£°ä¼ è¯‘å‘˜ï¼ˆ${state.lang === "fr-FR" ? "æ³•è¯­â†’ä¸­æ–‡" : "è‹±è¯­â†’ä¸­æ–‡"}ï¼‰ã€‚
è¯¾ç¨‹ä¸»é¢˜ï¼š${job.topic}

ã€ç¡¬æ€§è¾“å‡ºæ ¼å¼è¦æ±‚ã€‘
1) åªè¾“å‡ºè¯‘æ–‡æ­£æ–‡ï¼Œä¸è¦æ ‡é¢˜/è§£é‡Š/è¦ç‚¹/æ€»ç»“/è¡¥å……èƒŒæ™¯ã€‚
2) æŠŠå£è¯­ç¢ç‰‡æ•´ç†æˆä¸€æ®µè¿è´¯ä¸­æ–‡ï¼›å¦‚æœåŸæ–‡å¾ˆé•¿ï¼Œæœ€å¤šåˆ†æˆ2æ®µï¼ˆç”¨ä¸€ä¸ªç©ºè¡Œåˆ†éš”ï¼‰ã€‚
3) å»æ‰æ˜æ˜¾çš„å£å¤´ç¦…å’Œé‡å¤ï¼Œä½†ä¸è¦åˆ æ‰ä¿¡æ¯ç‚¹ã€‚
4) çº æ­£ASRé”™è¯¯ï¼šæ–­å¥ã€æ‹¼å†™ã€äººååœ°åã€è¿è¯»é€ æˆçš„é”™è¯ã€‚
5) æœ¯è¯­ä¸€è‡´æ€§æœ€é«˜ï¼šè‹¥æœ¯è¯­è¡¨æœ‰å¯¹åº”ï¼Œå¿…é¡»æŒ‰æœ¯è¯­è¡¨ç¿»è¯‘ï¼›è‹¥æ— ï¼ŒæŠŠæœ¯è¯­ä¿ç•™åŸæ–‡å¹¶åœ¨é¦–æ¬¡å‡ºç°æ—¶æ‹¬å·ç»™å‡ºä¸­æ–‡é‡Šä¹‰
ã€ASR çº é”™ã€‘
- è‡ªåŠ¨ä¿®æ­£è¯­éŸ³è¯†åˆ«é”™è¯¯ï¼šæ–­å¥ã€æ‹¼å†™ã€äººååœ°åã€é‡å¤ç‰‡æ®µã€‚

ã€æœ¯è¯­ä¸€è‡´æ€§ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰ã€‘
- è‹¥æœ¯è¯­è¡¨ä¸­å­˜åœ¨å¯¹åº”ï¼šå¿…é¡»æŒ‰æœ¯è¯­è¡¨ç¿»è¯‘ã€‚
æœ¯è¯­è¡¨ï¼ˆå¯ä¸ºç©ºï¼‰ï¼š
${glossaryBlock || "(æ— )"}

ã€ä¸Šä¸‹æ–‡ï¼ˆä¿æŒåŒä¸€è¯¾æœ¯è¯­ä¸€è‡´ï¼‰ã€‘
${ctx || "(æ— )"}

ã€å¯é€‰ï¼šè‡ªåŠ¨æå–æ–°æœ¯è¯­ï¼ˆç”¨äºå‰ç«¯æ›´æ–°ï¼Œä¸å±•ç¤ºç»™ç”¨æˆ·ï¼‰ã€‘
- å¦‚æœå‘ç°åŸæ–‡ä¸­å‡ºç°æ–°æœ¯è¯­/ä¸“æœ‰åè¯ï¼Œè¯·åœ¨è¯‘æ–‡æœ«å°¾è¿½åŠ ï¼š
<<<TERMS>>>
æœ¯è¯­=ä¸­æ–‡è§£é‡Š
...
<<<ENDTERMS>>>
- å¦‚æœæ²¡æœ‰æ–°æœ¯è¯­ï¼Œä¸è¦è¾“å‡º TERMS å—ã€‚
`.trim();

  const payload = {
    model: CONFIG.model,
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: job.raw }
    ],
    temperature: 0.2
  };

  const maxRetry = 3;
  for (let attempt = 1; attempt <= maxRetry; attempt++) {
    try {
      const resp = await fetch(CONFIG.url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify(payload)
      });

      // 401/403ï¼šæš‚åœé˜Ÿåˆ—ï¼Œç­‰ä½ æ”¹å¥½ key è‡ªåŠ¨ç»­
      if (resp.status === 401 || resp.status === 403) {
        TRANSLATE.pausedByAuth = true;
        // æŠŠå½“å‰ job æ”¾å›é˜Ÿåˆ—å¤´
        TRANSLATE.queue.unshift(job);
        updateNote(job.blockId, "âš ï¸ ç¿»è¯‘å¤±è´¥ï¼šAPI Key æ— æ•ˆæˆ–æ— æƒé™ï¼ˆHTTP 401/403ï¼‰\nï¼ˆå·²æš‚åœé˜Ÿåˆ—ï¼šä½ ä¿®å¥½ Key åä¼šè‡ªåŠ¨ç»§ç»­ï¼‰", true);
        return;
      }

      if (!resp.ok) {
        const msg = `HTTP ${resp.status}`;
        if (resp.status === 429 || resp.status >= 500) throw new Error("å¯é‡è¯•é”™è¯¯ï¼ˆ" + msg + "ï¼‰");
        throw new Error("è¯·æ±‚å¤±è´¥ï¼ˆ" + msg + "ï¼‰");
      }

      const data = await resp.json();
      let out = (data?.choices?.[0]?.message?.content || "").trim();
      if (!out) throw new Error("è¿”å›ä¸ºç©º");

      const { mainText, termPairs } = splitTermsBlock(out);

      updateNote(job.blockId, mainText, false);

      TRANSLATE.recentTranslations.push(mainText);
      if (TRANSLATE.recentTranslations.length > TRANSLATE.maxRecent) TRANSLATE.recentTranslations.shift();

      if (UI.autoTerms.checked && termPairs.length) {
        mergeTermsToGlossary(termPairs);
      }

      saveToLocal();
      return;

    } catch (e) {
      console.error(e);
      if (attempt === maxRetry) {
        updateNote(job.blockId, `âš ï¸ ç¿»è¯‘å¤±è´¥ï¼š${e.message}\nï¼ˆåŸæ–‡å·²ä¿ç•™ï¼Œå¯ç¨åé‡è¯•ï¼‰`, true);
        saveToLocal();
        return;
      }
      await new Promise(r => setTimeout(r, 450 * Math.pow(2, attempt)));
    }
  }
}

// ===== è§£æéšè—æœ¯è¯­å— =====
function splitTermsBlock(text){
  const start = text.indexOf("<<<TERMS>>>");
  const end = text.indexOf("<<<ENDTERMS>>>");
  if (start >= 0 && end > start) {
    const mainText = (text.slice(0, start)).trim();
    const block = text.slice(start + "<<<TERMS>>>".length, end).trim();
    const lines = block.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const pairs = [];
    for (const line of lines) {
      const idx = line.indexOf("=");
      if (idx > 0) {
        const k = line.slice(0, idx).trim();
        const v = line.slice(idx + 1).trim();
        if (k && v) pairs.push([k, v]);
      }
    }
    return { mainText, termPairs: pairs };
  }
  return { mainText: text.trim(), termPairs: [] };
}

function mergeTermsToGlossary(pairs){
  const current = parseGlossary();
  const map = new Map(current.map(([k,v]) => [k.toLowerCase(), [k,v]]));

  let changed = false;
  for (const [k, v] of pairs) {
    const key = k.toLowerCase();
    if (!map.has(key)) {
      map.set(key, [k, v]);
      changed = true;
    }
  }
  if (!changed) return;

  const merged = Array.from(map.values())
    .sort((a,b) => a[0].localeCompare(b[0], "zh-CN"))
    .map(([k,v]) => `${k}=${v}`)
    .join("\n");

  UI.glossary.value = merged;
  localStorage.setItem(CONFIG.glossaryKey, merged);
}

// ===== æ¸²æŸ“ç¬”è®°ï¼ˆå¸¦å¤åˆ¶æŒ‰é’®ï¼‰=====
function renderNoteBlock(note){
  const html = `
    <div class="note-block" id="${note.id}">
      <div class="note-header">
        <span>ğŸ•’ ${escapeHtml(note.time)}</span>
        <span class="status-tag" style="color:#f39c12">è®¡ç®—ä¸­â€¦</span>
      </div>
      <div class="content-row">
        <div>
          <div class="text-origin" id="${note.id}-raw">${escapeHtml(note.raw)}</div>
          <div class="tool-bar">
            <button class="mini-btn" onclick="copyById('${note.id}-raw')">å¤åˆ¶åŸæ–‡</button>
          </div>
        </div>

        <div style="margin-top:6px;border-top:1px dashed #eee;padding-top:10px;">
          <div class="text-trans" id="${note.id}-trans">${escapeHtml(note.trans)}</div>
          <div class="tool-bar">
            <button class="mini-btn" onclick="copyById('${note.id}-trans')">å¤åˆ¶è¯‘æ–‡</button>
          </div>
        </div>
      </div>
    </div>
  `;
  UI.container.insertAdjacentHTML("beforeend", html);
  UI.welcome.style.display = "none";
}

function updateNote(blockId, text, isError){
  const block = document.getElementById(blockId);
  if (!block) return;

  const safe = escapeHtml(text).replace(/\*\*(.*?)\*\*/g, "<b>$1</b>");
  const transDiv = document.getElementById(blockId + "-trans");
  transDiv.innerHTML = isError ? `<span style="color:red">${safe}</span>` : safe;

  const tag = block.querySelector(".status-tag");
  tag.innerText = isError ? "é”™è¯¯" : "å·²ç¿»è¯‘";
  tag.style.color = isError ? "red" : "var(--success)";

  const n = state.noteHistory.find(x => x.id === blockId);
  if (n) {
    n.trans = text;
    n.status = isError ? "error" : "done";
  }

  smartScroll();
}

// ===== å¤åˆ¶ï¼šä¼˜å…ˆ clipboardï¼Œå¤±è´¥å°± execCommand é™çº§ =====
async function copyById(id){
  const el = document.getElementById(id);
  if (!el) return;
  const text = el.innerText || "";

  try{
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(text);
    } else {
      fallbackCopyText(text);
    }
    flashCopy(el);
  } catch {
    fallbackCopyText(text);
    flashCopy(el);
  }
}

function fallbackCopyText(text){
  const ta = document.createElement("textarea");
  ta.value = text;
  ta.style.position = "fixed";
  ta.style.left = "-9999px";
  ta.style.top = "-9999px";
  document.body.appendChild(ta);
  ta.focus();
  ta.select();
  try { document.execCommand("copy"); } catch {}
  document.body.removeChild(ta);
}

function flashCopy(el){
  const old = el.style.background;
  el.style.background = "#dff9fb";
  setTimeout(() => el.style.background = old, 220);
}

// ===== æŒä¹…åŒ– =====
function saveToLocal(){
  localStorage.setItem(CONFIG.localStorageKey, JSON.stringify(state.noteHistory));
}
function restoreSession(){
  const backup = localStorage.getItem(CONFIG.localStorageKey);
  if (!backup) return;

  try{
    const data = JSON.parse(backup);
    if (!Array.isArray(data)) return;

    state.noteHistory = data;
    UI.container.innerHTML = "";
    state.noteHistory.forEach(note => {
      renderNoteBlock(note);
      if (note.trans === "â³ æ­£åœ¨ç¿»è¯‘â€¦" || note.status === "pending") {
        updateNote(note.id, "âš ï¸ æ¢å¤çš„æ•°æ®ï¼šåŸæ–‡å·²ä¿å­˜ï¼Œä½†æœªå®Œæˆç¿»è¯‘ã€‚", true);
      } else {
        updateNote(note.id, note.trans, false);
      }
    });

    UI.restoreBar.style.display = "none";
    UI.welcome.style.display = "none";
    scrollToBottomForce();
  } catch {}
}

function clearSession(){
  if (!confirm("ç¡®å®šæ¸…ç©ºæ‰€æœ‰ç¬”è®°å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚")) return;
  state.noteHistory = [];
  TRANSLATE.recentTranslations = [];
  TRANSLATE.queue = [];
  TRANSLATE.pausedByAuth = false;

  localStorage.removeItem(CONFIG.localStorageKey);
  UI.container.innerHTML = "";
  UI.welcome.style.display = "block";
  UI.restoreBar.style.display = "none";
}

// ===== æ§åˆ¶ï¼šä¸Šè¯¾/ä¸‹è¯¾ =====
async function startSession(){
  if (!UI.apiKey.value.trim()) { alert("è¯·å…ˆè¾“å…¥ DeepSeek API Key"); return; }

  // å…ˆæ‹¿ä¸€æ¬¡éº¦å…‹é£æƒé™ï¼ˆé¿å…åå¤å¼¹ï¼‰
  const ok = await ensureMicPermission();
  if (!ok) return;

  // wakelockï¼ˆå°½é‡åˆ«ç¡çœ ï¼‰
  await enableWakeLock();

  if (!state.recognition) initSpeech();
  updateUiState(true);
  UI.bottomBar.classList.remove("hidden");

  try { state.recognition.start(); } catch {}
}

async function stopSession(){
  state.recording = false;

  if (state.timer) clearTimeout(state.timer);
  if (interimCommitTimer) clearTimeout(interimCommitTimer);

  try { state.recognition && state.recognition.stop(); } catch {}

  if (state.buffer.trim()) await flushBuffer("åœæ­¢ä¼šè¯æ”¶å°¾");

  UI.status.innerText = "ğŸ§¹ æ­£åœ¨æ”¶å°¾ç¿»è¯‘â€¦";
  while (TRANSLATE.running || TRANSLATE.queue.length) {
    await new Promise(r => setTimeout(r, 120));
  }

  disableWakeLock();

  updateUiState(false);
  UI.status.innerText = "âœ… å·²åœæ­¢ï¼ˆç¿»è¯‘å®Œæˆï¼‰";
}

function updateUiState(isRecording){
  UI.btnStart.style.display = isRecording ? "none" : "flex";
  UI.btnStop.style.display = isRecording ? "flex" : "none";

  if (isRecording) {
    UI.bottomBar.classList.remove("hidden");
    UI.welcome.style.display = "none";
  } else {
    UI.bottomBar.classList.add("hidden");
  }
}

// ===== å¯¼å‡º Word =====
function exportWord(){
  const topic = UI.topic.value || "æ³•è¯­è¯¾å ‚ç¬”è®°";
  const date = new Date().toLocaleString();

  let doc = `
    <html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word'>
    <head><meta charset='utf-8'><title>${escapeHtml(topic)}</title></head>
    <body style="font-family:'Microsoft YaHei',sans-serif">
      <h1 style="text-align:center;color:#2c3e50;">${escapeHtml(topic)}</h1>
      <p style="text-align:center;color:#7f8c8d;font-size:12px;">ç”Ÿæˆæ—¶é—´: ${escapeHtml(date)}</p>
      <hr/>
  `;

  state.noteHistory.forEach(note => {
    doc += `
      <div style="margin-bottom:18px;border:1px solid #eee;padding:12px;border-radius:8px;">
        <p style="margin:0 0 6px 0;font-size:10px;color:#999;">${escapeHtml(note.time || "")}</p>
        <p style="font-family:Georgia;color:#555;font-style:italic;margin:5px 0;white-space:pre-wrap;">${escapeHtml(note.raw || "")}</p>
        <p style="font-weight:bold;color:#000;margin:8px 0;white-space:pre-wrap;line-height:1.7;">${escapeHtml(note.trans || "")}</p>
      </div>
    `;
  });

  doc += `</body></html>`;

  const blob = new Blob([doc], { type: "application/msword" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = `${topic}_${Date.now()}.doc`;
  link.click();
}

// ===== XSS é˜²æŠ¤ =====
function escapeHtml(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
</script>
</body>
</html>
