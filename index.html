<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ğŸ‡«ğŸ‡· æ³•è¯­è¯¾å ‚åŒå£°ä¼ è¯‘ (Pro MAXï¼šæ®µè½/é˜Ÿåˆ—/å»é‡/æŠ¢æ•‘interim/å¯æ¢å¤/ä¸ä¹±æ»š/è‡ªåŠ¨ç»­ç¿»è¯‘)</title>
  <style>
    :root{
      --primary:#2c3e50;
      --accent:#2980b9;
      --bg:#f4f6f9;
      --card:#ffffff;
      --success:#27ae60;
      --danger:#e74c3c;
      --muted:#7f8c8d;
    }
    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif;
      background:var(--bg); margin:0; padding:0;
      display:flex; flex-direction:column; height:100vh; overflow:hidden;
    }
    header{
      background:var(--card);
      padding:12px 20px;
      box-shadow:0 2px 10px rgba(0,0,0,.05);
      z-index:100; flex-shrink:0;
      border-bottom:1px solid #e1e4e8;
    }
    .header-row{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      flex-wrap:wrap; margin-bottom:8px;
    }
    .header-row:last-child{ margin-bottom:0; }

    input, textarea{
      padding:8px 12px; border:1px solid #dfe6e9; border-radius:6px; outline:none;
      font-size:14px; background:#fafafa; transition:.2s;
      box-sizing:border-box;
    }
    input:focus, textarea:focus{ border-color:var(--accent); background:white; }

    .lang-switch{ display:flex; background:#ecf0f1; border-radius:6px; padding:2px; }
    .lang-btn{
      padding:6px 12px; border:none; background:transparent; cursor:pointer;
      font-size:13px; font-weight:700; color:#7f8c8d; border-radius:4px;
    }
    .lang-btn.active{ background:white; color:var(--accent); box-shadow:0 1px 3px rgba(0,0,0,.1); }

    .btn-action{
      padding:8px 16px; border:none; border-radius:6px;
      font-weight:800; cursor:pointer; color:white; transition:.2s;
      font-size:14px; display:flex; align-items:center; gap:6px;
    }
    .btn-action:active{ transform:translateY(1px); }
    .btn-action:hover{ opacity:.92; }
    #btn-start{ background:var(--success); }
    #btn-stop{ background:var(--danger); display:none; }
    #btn-export{ background:var(--accent); }
    #btn-clear{ background:#95a5a6; }
    #btn-glossary{ background:#8e44ad; }

    #restore-bar{
      background:#fff3cd; color:#856404;
      padding:10px; text-align:center; font-size:14px;
      display:none; cursor:pointer; border-bottom:1px solid #ffeeba;
    }

    #container{
      flex:1; overflow-y:auto; padding:20px;
      padding-bottom:230px;
      max-width:960px; margin:0 auto; width:100%; box-sizing:border-box;
    }

    .note-block{
      background:var(--card); border-radius:12px;
      box-shadow:0 4px 15px rgba(0,0,0,.03);
      margin-bottom:22px; overflow:hidden; border:1px solid #edf2f7;
      animation:slideIn .22s ease;
    }
    @keyframes slideIn{ from{opacity:0; transform:translateY(14px);} to{opacity:1; transform:translateY(0);} }

    .note-header{
      padding:8px 15px; background:#fafbfc; border-bottom:1px solid #f0f0f0;
      display:flex; justify-content:space-between; align-items:center;
      font-size:12px; color:#95a5a6;
    }
    .status-tag{ font-weight:900; }

    .content-row{ padding:15px; display:flex; flex-direction:column; gap:12px; }

    .text-origin{
      font-family:Georgia, serif; font-size:14px; color:#7f8c8d; line-height:1.55;
      background:#f8f9fa; padding:10px; border-radius:8px;
      border-left:3px solid #cbd5e0;
      white-space:pre-wrap; word-break:break-word;
    }
    .text-trans{
      font-size:16px; color:#2c3e50; line-height:1.85; font-weight:500;
      padding:0 5px; text-align:justify;
      white-space:pre-wrap; word-break:break-word;
    }
    .text-trans b{ color:#d35400; background:rgba(241,196,15,.12); padding:0 2px; border-radius:3px; }

    .tool-bar{ display:flex; justify-content:flex-end; gap:10px; margin-top:6px; }
    .mini-btn{
      font-size:11px; color:#95a5a6; background:white; border:1px solid #e1e4e8;
      padding:4px 9px; border-radius:4px; cursor:pointer;
      user-select:none;
    }
    .mini-btn:hover{ border-color:var(--accent); color:var(--accent); }

    #bottom-bar{
      position:fixed; bottom:0; left:0; width:100%;
      background:rgba(255,255,255,.98);
      border-top:1px solid #eee; padding:12px 20px;
      box-shadow:0 -5px 20px rgba(0,0,0,.05);
      z-index:900; backdrop-filter:blur(10px);
      transition:transform .3s;
    }
    #bottom-bar.hidden{ transform:translateY(120%); }

    .status-line{ display:flex; justify-content:space-between; font-size:12px; color:#7f8c8d; margin-bottom:6px; }
    .live-preview{
      height:70px; overflow-y:auto; color:#34495e; font-size:14px;
      background:#f1f2f6; border-radius:6px; padding:10px; border:1px solid #eee;
      white-space:pre-wrap; word-break:break-word;
    }
    .rec-dot{
      width:10px; height:10px; background:red; border-radius:50%;
      display:inline-block; margin-right:6px; animation:pulse 1.5s infinite;
    }
    @keyframes pulse{ 0%{opacity:1} 50%{opacity:.35} 100%{opacity:1} }

    #scroll-btn{
      position:fixed; bottom:190px; right:30px;
      background:var(--accent); color:white;
      width:42px; height:42px; border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      box-shadow:0 4px 12px rgba(41,128,185,.3);
      cursor:pointer; z-index:800;
      opacity:0; transition:.25s; pointer-events:none; font-weight:900;
      user-select:none;
    }
    #scroll-btn.show{ opacity:1; pointer-events:auto; }
    #scroll-badge{
      position:absolute; top:-5px; right:-5px;
      background:var(--danger); width:10px; height:10px; border-radius:50%;
      display:none;
    }

    /* æœ¯è¯­è¡¨æŠ˜å åŒº */
    #glossary-panel{
      display:none;
      margin-top:10px;
      padding:12px;
      background:#fbf6ff;
      border:1px solid #eadcf6;
      border-radius:10px;
    }
    #glossary-panel h4{ margin:0 0 8px 0; color:#5d3b7a; font-size:13px; }
    #glossary{
      width:100%;
      min-height:84px;
      resize:vertical;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      background:#fff;
    }
    .glossary-row{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      margin-top:8px; color:#5d3b7a; font-size:12px;
    }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      background:#efe5fb; border:1px solid #e3d2fb;
      padding:6px 10px; border-radius:999px;
    }
    .hint{
      color:#8c6aa8;
      font-size:12px;
    }

    @media (max-width:768px){
      .header-row{ flex-direction:column; align-items:stretch; }
      #container{ padding:10px; padding-bottom:240px; }
      .btn-action{ justify-content:center; }
      #scroll-btn{ right:16px; }
    }
  </style>
</head>
<body>

<div id="restore-bar">âš ï¸ æ£€æµ‹åˆ°ä¸Šæ¬¡è¯¾ç¨‹å†…å®¹ï¼Œç‚¹è¿™é‡Œæ¢å¤</div>

<header>
  <div class="header-row">
    <div style="font-weight:900;color:var(--primary);display:flex;align-items:center;gap:10px;">
      ğŸ“ åŒå£°ä¼ è¯‘ Pro MAX
      <div class="lang-switch">
        <button class="lang-btn active" id="btn-fr">FR æ³•è¯­</button>
        <button class="lang-btn" id="btn-en">EN è‹±è¯­</button>
      </div>
    </div>
    <div style="display:flex;gap:10px;flex:1;justify-content:flex-end;flex-wrap:wrap;">
      <input type="password" id="api-key" placeholder="ç²˜è´´ DeepSeek API Key" style="width:240px;">
    </div>
  </div>

  <div class="header-row" style="margin-top:10px;">
    <input type="text" id="topic-input" placeholder="è¾“å…¥è¯¾ç¨‹ä¸»é¢˜ï¼ˆä¾‹å¦‚: Droit civil / SIG / MobilitÃ©ï¼‰" style="flex:1;">
    <button id="btn-glossary" class="btn-action">ğŸ“š æœ¯è¯­è¡¨</button>
    <button id="btn-start" class="btn-action">ğŸ™ï¸ ä¸Šè¯¾</button>
    <button id="btn-stop" class="btn-action">â¹ ä¸‹è¯¾</button>
    <button id="btn-export" class="btn-action">ğŸ’¾ å¯¼å‡º Word</button>
    <button id="btn-clear" class="btn-action" style="font-size:12px;padding:8px 12px;">ğŸ—‘ï¸ æ¸…ç©º</button>
  </div>

  <div id="glossary-panel">
    <h4>å¯é€‰æœ¯è¯­è¡¨ï¼ˆæ¯è¡Œä¸€æ¡ï¼‰ï¼š<span style="color:#8e44ad;">æœ¯è¯­=ä¸­æ–‡è§£é‡Š</span>ï¼ˆåªå¡«å¸¸ç”¨ 10~30 æ¡å°±å¤Ÿï¼‰</h4>
    <textarea id="glossary" placeholder="EPCI=å¸‚é•‡é—´å…¬å…±åˆä½œæœºæ„
amÃ©nagement=è§„åˆ’
mobilitÃ©=å‡ºè¡Œ/æµåŠ¨æ€§
tramway=æœ‰è½¨ç”µè½¦"></textarea>
    <div class="glossary-row">
      <span class="pill">
        <input type="checkbox" id="auto-terms" checked />
        <label for="auto-terms" style="cursor:pointer;">è‡ªåŠ¨ä»ç¿»è¯‘é‡Œæå–æ–°æœ¯è¯­å¹¶è®°å¿†</label>
      </span>
      <span class="pill">
        <input type="checkbox" id="paragraph-mode" checked />
        <label for="paragraph-mode" style="cursor:pointer;">æ®µè½æ¨¡å¼ï¼ˆå…ˆæ”’ä¸€æ®µå†ç¿»è¯‘ï¼‰</label>
      </span>
      <span class="pill">
        <button class="mini-btn" id="btn-save-glossary">ä¿å­˜æœ¯è¯­è¡¨</button>
        <button class="mini-btn" id="btn-clear-glossary">æ¸…ç©ºæœ¯è¯­è¡¨</button>
      </span>
      <span class="hint">æç¤ºï¼šæœ¯è¯­è¡¨å­˜æœ¬æœº localStorageï¼Œä¸ä¸Šä¼ ã€‚401 ä¿®å¥½ Key ä¼šè‡ªåŠ¨ç»­ç¿»è¯‘ã€‚</span>
    </div>
  </div>
</header>

<div id="container">
  <div style="text-align:center;color:#bdc3c7;margin-top:80px;" id="welcome-msg">
    <h3>ğŸ‘‹ å‡†å¤‡å°±ç»ª</h3>
    <p>è¾“å…¥è¯¾ç¨‹ä¸»é¢˜ï¼Œç‚¹â€œä¸Šè¯¾â€å¼€å§‹è®°å½•</p>
    <p style="font-size:12px;">âœ… é˜Ÿåˆ—ä¸ä¹±åº Â· âœ… æ–­çº¿æ¢å¤ Â· âœ… æ®µè½è¾“å‡º Â· âœ… æŠ¢æ•‘ interim é˜²è¦†ç›– Â· âœ… ä¸ä¹±æ»šåŠ¨</p>
  </div>
</div>

<div id="scroll-btn">â¬‡<div id="scroll-badge"></div></div>

<div id="bottom-bar" class="hidden">
  <div class="status-line">
    <span id="status-text"><span class="rec-dot"></span>æ­£åœ¨è†å¬è€å¸ˆå‘è¨€â€¦</span>
    <span id="char-count">ç¼“å†²åŒº: 0å­—</span>
  </div>
  <div class="live-preview" id="live-text"></div>
</div>

<script>
/**
 * âš ï¸ corsproxy.io æ˜¯ç¬¬ä¸‰æ–¹ä»£ç†ï¼ˆä¸ç¨³å®š/ä¸å®‰å…¨ï¼‰ã€‚
 * çœŸé•¿æœŸç”¨ï¼šå»ºè®®è‡ªå»ºè½¬å‘ï¼ˆCloudflare Worker/Vercel/Nodeï¼‰ï¼Œå†æŠŠ CONFIG.url æ”¹æˆä½ çš„è½¬å‘åœ°å€ã€‚
 */
const CONFIG = {
  url: "https://YOUR_PROXY_ENDPOINT/translate",
  // authMode:
  //  - "proxy": å‰ç«¯ä¸æºå¸¦ Authorizationï¼Œç”±ä½ è‡ªå·±çš„ä»£ç†/Worker æ³¨å…¥ Keyï¼ˆæ¨èï¼ŒGitHub Pages å¯ç”¨ï¼‰
  //  - "browser": å‰ç«¯ç›´æ¥æºå¸¦ Authorizationï¼ˆéœ€è¦ç›®æ ‡ç«™ç‚¹å…è®¸ CORSï¼Œä¸€èˆ¬ä¸è¡Œï¼›ä»…æœ¬åœ°åŒæºåœºæ™¯ï¼‰
  authMode: "proxy",
  // å½“ authMode="browser" æ—¶ä½¿ç”¨ï¼ˆdeepseek æ ‡å‡†åœ°å€ï¼‰ï¼š
  directUrl: "https://api.deepseek.com/v1/chat/completions",
  model: "deepseek-chat",

  // æ®µè½ç­–ç•¥
  minCharsToSend: 150,
  maxCharsForce: 1100,
  silenceThreshold: 3800,
  punctuationWait: 1100,
  forceFlushMs: 6500,

  localStorageKey: "classroom_trans_backup_v3",
  glossaryKey: "classroom_glossary_v1"
};

let state = {
  recording: false,
  buffer: "",
  interim: "",
  timer: null,
  lang: "fr-FR",
  recognition: null,
  userScrolled: false,
  noteHistory: []
};

const UI = {
  container: document.getElementById("container"),
  liveText: document.getElementById("live-text"),
  status: document.getElementById("status-text"),
  count: document.getElementById("char-count"),
  restoreBar: document.getElementById("restore-bar"),
  welcome: document.getElementById("welcome-msg"),
  bottomBar: document.getElementById("bottom-bar"),
  scrollBtn: document.getElementById("scroll-btn"),
  scrollBadge: document.getElementById("scroll-badge"),

  glossaryPanel: document.getElementById("glossary-panel"),
  glossary: document.getElementById("glossary"),
  autoTerms: document.getElementById("auto-terms"),
  paragraphMode: document.getElementById("paragraph-mode"),

  apiKey: document.getElementById("api-key"),
  topic: document.getElementById("topic-input"),

  btnFr: document.getElementById("btn-fr"),
  btnEn: document.getElementById("btn-en"),
  btnGlossary: document.getElementById("btn-glossary"),
  btnStart: document.getElementById("btn-start"),
  btnStop: document.getElementById("btn-stop"),
  btnExport: document.getElementById("btn-export"),
  btnClear: document.getElementById("btn-clear"),
  btnSaveGlossary: document.getElementById("btn-save-glossary"),
  btnClearGlossary: document.getElementById("btn-clear-glossary"),
};

// ====== ç¿»è¯‘é˜Ÿåˆ—ï¼ˆä¸²è¡Œã€ä¸ä¹±åºï¼‰======
const TRANSLATE = {
  queue: [],
  running: false,
  seq: 0,
  recentTranslations: [],
  maxRecent: 12,
  lastFinalTail: "",
  pausedByAuth: false
};

// ====== æŠ¢æ•‘ interim ======
let lastInterim = "";
let lastInterimAt = 0;
let interimCommitTimer = null;
const INTERIM_STABLE_MS = 700;
const INTERIM_MIN_CHARS = 12;

let lastBufferUpdateAt = Date.now();
let forceFlushTimer = null; // é˜²æ­¢ forceFlush å®šæ—¶å™¨å †ç§¯

// ====== è¯†åˆ«é‡å¯é™é¢‘/é€€é¿ï¼ˆé˜²æ­¢ç–¯ç‹‚å¼¹æƒé™/ç–¯ç‹‚é‡å¯ï¼‰=====
let lastRecStartAt = 0;
let recRestartCooldown = 800;

// ====== Wake Lockï¼ˆå°½é‡é˜²æ­¢é¡µé¢ä¼‘çœ ï¼‰=====
let wakeLock = null;

function bindUI(){
  UI.btnGlossary.addEventListener("click", toggleGlossary);

  UI.btnFr.addEventListener("click", () => setLang("fr"));
  UI.btnEn.addEventListener("click", () => setLang("en"));

  UI.btnStart.addEventListener("click", startSession);
  UI.btnStop.addEventListener("click", stopSession);
  UI.btnExport.addEventListener("click", exportWord);
  UI.btnClear.addEventListener("click", clearSession);

  UI.btnSaveGlossary.addEventListener("click", saveGlossary);
  UI.btnClearGlossary.addEventListener("click", clearGlossary);

  UI.restoreBar.addEventListener("click", restoreSession);
  UI.scrollBtn.addEventListener("click", scrollToBottomForce);

  // ä¿®å¥½ API Key åè‡ªåŠ¨ç»­ç¿»è¯‘
  UI.apiKey.addEventListener("input", () => {
    const k = UI.apiKey.value.trim();
    if (k.length > 10 && TRANSLATE.pausedByAuth) {
      TRANSLATE.pausedByAuth = false;
      if (!TRANSLATE.running && TRANSLATE.queue.length) runTranslateQueue();
    }
  });

  UI.container.addEventListener("scroll", () => {
    const dist = UI.container.scrollHeight - UI.container.scrollTop - UI.container.clientHeight;
    state.userScrolled = dist > 140;
    updateScrollBtn();
  });

  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
      // å›åˆ°å‰å°ï¼šå°è¯•é‡å¯è¯†åˆ«
      if (state.recording) safeRestartRecognition("visibilitychange");
      // æ¢å¤ wakelock
      if (state.recording) enableWakeLock();
    } else {
      // åå°æ—¶é‡Šæ”¾ wakelockï¼ˆæµè§ˆå™¨ä¸€èˆ¬ä¹Ÿä¼šé‡Šæ”¾ï¼‰
      // ä¸å¼ºæ±‚
    }
  });

  window.addEventListener("focus", () => {
    if (state.recording) safeRestartRecognition("focus");
  });

  window.onbeforeunload = () => {
    saveToLocal();
    localStorage.setItem(CONFIG.glossaryKey, UI.glossary.value || "");
  };
}

window.onload = () => {
  bindUI();

  // æ¢å¤ API Key/æœ¯è¯­è¡¨
  const key = localStorage.getItem("ds_api_key");
  if (key) UI.apiKey.value = key;

  const g = localStorage.getItem(CONFIG.glossaryKey);
  if (g) UI.glossary.value = g;

  // æ£€æŸ¥æ˜¯å¦æœ‰å¤‡ä»½
  const backup = localStorage.getItem(CONFIG.localStorageKey);
  if (backup) {
    try {
      const data = JSON.parse(backup);
      if (Array.isArray(data) && data.length > 0) {
        UI.restoreBar.style.display = "block";
        UI.welcome.style.display = "none";
      }
    } catch {}
  }

  // favicon 404 ä¸å½±å“åŠŸèƒ½
};

// ===== UIï¼šæ»šåŠ¨é”å®š =====
function updateScrollBtn(){
  UI.scrollBtn.classList.toggle("show", state.userScrolled);
  if (!state.userScrolled) UI.scrollBadge.style.display = "none";
}
function scrollToBottomForce(){
  UI.container.scrollTop = UI.container.scrollHeight;
  state.userScrolled = false;
  updateScrollBtn();
}
function smartScroll(){
  if (!state.userScrolled) UI.container.scrollTop = UI.container.scrollHeight;
  else UI.scrollBadge.style.display = "block";
}

// ===== æœ¯è¯­è¡¨ =====
function toggleGlossary(){
  UI.glossaryPanel.style.display = (UI.glossaryPanel.style.display === "block") ? "none" : "block";
}
function saveGlossary(){
  localStorage.setItem(CONFIG.glossaryKey, UI.glossary.value || "");
  alert("âœ… æœ¯è¯­è¡¨å·²ä¿å­˜ï¼ˆæœ¬æœº localStorageï¼‰");
}
function clearGlossary(){
  if (!confirm("ç¡®å®šæ¸…ç©ºæœ¯è¯­è¡¨ï¼Ÿ")) return;
  UI.glossary.value = "";
  localStorage.removeItem(CONFIG.glossaryKey);
}
function parseGlossary(){
  const text = (UI.glossary.value || "").trim();
  if (!text) return [];
  const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  const pairs = [];
  for (const line of lines) {
    const idx = line.indexOf("=");
    if (idx > 0) {
      const k = line.slice(0, idx).trim();
      const v = line.slice(idx + 1).trim();
      if (k && v) pairs.push([k, v]);
    }
  }
  return pairs;
}
function glossaryToPromptBlock(){
  const pairs = parseGlossary();
  if (!pairs.length) return "";
  return pairs.map(([k,v]) => `${k}=${v}`).join("\n");
}

// ===== è¯­è¨€åˆ‡æ¢ =====
function setLang(l){
  document.querySelectorAll(".lang-btn").forEach(b => b.classList.remove("active"));
  if (l === "fr") UI.btnFr.classList.add("active");
  else UI.btnEn.classList.add("active");

  state.lang = (l === "fr") ? "fr-FR" : "en-US";
  if (state.recording) {
    try { state.recognition && state.recognition.stop(); } catch {}
  }
}

// ===== å…³é”®ï¼šå…ˆèµ°ä¸€æ¬¡ getUserMediaï¼Œé¿å…åå¤å¼¹æƒé™ =====
async function ensureMicPermission(){
  if (!navigator.mediaDevices?.getUserMedia) {
    alert("âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£è®¿é—®ï¼Œè¯·ç”¨ Chromeã€‚");
    return false;
  }

  // å¦‚æœæƒé™è¢«æ‹’ç»ï¼Œç›´æ¥æç¤º
  if (navigator.permissions?.query) {
    try {
      const st = await navigator.permissions.query({ name: "microphone" });
      if (st.state === "denied") {
        alert("éº¦å…‹é£æƒé™è¢«æ‹’ç»ï¼šè¯·ç‚¹åœ°å€æ å·¦è¾¹ğŸ”’/i â†’ Site settings â†’ Microphone â†’ Allow");
        return false;
      }
    } catch {}
  }

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(t => t.stop()); // åªä¸ºæ‹¿æƒé™
    return true;
  } catch {
    alert("æ— æ³•è·å–éº¦å…‹é£æƒé™ï¼Œè¯·æ£€æŸ¥ç³»ç»Ÿ/æµè§ˆå™¨éº¦å…‹é£è®¾ç½®ã€‚");
    return false;
  }
}

// ===== Wake Lockï¼ˆå°½é‡ä¿æŒä¸ç¡çœ ï¼‰=====
async function enableWakeLock(){
  try{
    if ("wakeLock" in navigator) {
      if (wakeLock) return;
      wakeLock = await navigator.wakeLock.request("screen");
      wakeLock.addEventListener("release", () => { wakeLock = null; });
    }
  } catch {}
}
function disableWakeLock(){
  try{ wakeLock && wakeLock.release(); } catch {}
  wakeLock = null;
}

// ===== SpeechRecognition åˆå§‹åŒ– =====
function initSpeech(){
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert("âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ï¼Œè¯·ç”¨ Chromeã€‚");
    return false;
  }

  const rec = new SpeechRecognition();
  rec.lang = state.lang;
  rec.continuous = true;
  rec.interimResults = true;

  rec.onstart = () => {
    state.recording = true;
    updateUiState(true);
    UI.status.innerHTML = `<span class="rec-dot"></span>æ­£åœ¨è†å¬è€å¸ˆå‘è¨€â€¦`;
    lastRecStartAt = Date.now();
    recRestartCooldown = 800;
  };

  rec.onend = () => {
    if (state.recording) safeRestartRecognition("onend");
  };

  rec.onerror = (e) => {
    console.warn("Speech error:", e.error);
    // è¿™å‡ ä¸ªé”™è¯¯ä¸è¦ç–¯ç‹‚é‡å¯ï¼Œå¦åˆ™å®¹æ˜“åå¤å¼¹
    if (e.error === "not-allowed" || e.error === "service-not-allowed") {
      alert("âŒ æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®ã€‚");
      state.recording = false;
      updateUiState(false);
      return;
    }
    // å…¶ä»–é”™è¯¯ï¼Œäº¤ç»™ safeRestartRecognition åšé€€é¿é‡å¯
  };

  rec.onresult = (event) => {
    let newFinal = "";
    let newInterim = "";

    for (let i = event.resultIndex; i < event.results.length; i++){
      if (event.results[i].isFinal) newFinal += event.results[i][0].transcript;
      else newInterim += event.results[i][0].transcript;
    }

    if (newFinal) {
      const cleaned = dedupeFinalAppend(newFinal);
      if (cleaned) {
        state.buffer += cleaned + " ";
        lastBufferUpdateAt = Date.now();
        analyzeAndScheduleSend();
      }
    }

    state.interim = newInterim;
    scheduleInterimRescue(newInterim);
    updateLivePreview();
  };

  state.recognition = rec;
  return true;
}

// ===== è¯†åˆ«é‡å¯ï¼šé™é¢‘ + æŒ‡æ•°é€€é¿ =====
function safeRestartRecognition(reason){
  if (!state.recording || !state.recognition) return;

  const now = Date.now();
  if (now - lastRecStartAt < recRestartCooldown) return;

  try{
    state.recognition.lang = state.lang;
    state.recognition.start();
    lastRecStartAt = now;
    recRestartCooldown = 800;
  } catch {
    recRestartCooldown = Math.min(6000, Math.floor(recRestartCooldown * 1.6));
    setTimeout(() => {
      if (!state.recording) return;
      try{
        state.recognition.start();
        lastRecStartAt = Date.now();
      } catch {}
    }, recRestartCooldown);
  }
}

// ===== final å»é‡ =====
function normalizeForDedupe(s){
  return (s || "")
    .replace(/\s+/g, " ")
    .replace(/[ï¼Œ,ã€‚.!?ï¼Ÿï¼›;ï¼š:]/g, "")
    .trim()
    .toLowerCase();
}

function isProbablyDuplicate(existing, incoming){
  const a = normalizeForDedupe(existing).slice(-160);
  const b = normalizeForDedupe(incoming);
  if (!a || !b) return false;
  return a.endsWith(b) || b.endsWith(a) || a.includes(b);
}

// final ç»“æœå»é‡ï¼šæ¯”â€œå°¾å·´40å­—â€æ›´ç¨³
function dedupeFinalAppend(finalText){
  const t = (finalText || "").trim();
  if (!t) return "";
  if (isProbablyDuplicate(state.buffer, t)) return "";
  // ä¹Ÿé˜²æ­¢è¿ç»­é‡å¤æäº¤åŒä¸€æ®µ
  const tail = normalizeForDedupe(t).slice(-120);
  if (tail && TRANSLATE.lastFinalTailNorm && tail === TRANSLATE.lastFinalTailNorm) return "";
  TRANSLATE.lastFinalTailNorm = tail;
  return t;
}


// ===== interim æŠ¢æ•‘ =====
function scheduleInterimRescue(interimText){
  const now = Date.now();
  const t = (interimText || "").trim();

  if (t !== lastInterim) {
    lastInterim = t;
    lastInterimAt = now;
  }

  if (interimCommitTimer) clearTimeout(interimCommitTimer);
  interimCommitTimer = setTimeout(() => {
    const stableFor = Date.now() - lastInterimAt;
    if (stableFor >= INTERIM_STABLE_MS) {
      commitStableInterim();
      updateLivePreview();
    }
  }, INTERIM_STABLE_MS + 20);
}

function commitStableInterim(){
  if (!lastInterim) return;
  const t = lastInterim.trim();
  if (t.length < INTERIM_MIN_CHARS) return;

  const cut = Math.max(
    t.lastIndexOf(" "),
    t.lastIndexOf("."), t.lastIndexOf("?"), t.lastIndexOf("!"),
    t.lastIndexOf("ã€‚"), t.lastIndexOf("ï¼Ÿ"), t.lastIndexOf("ï¼"),
    t.lastIndexOf(","), t.lastIndexOf("ï¼Œ"),
    t.lastIndexOf(";"), t.lastIndexOf("ï¼›"),
    t.lastIndexOf(":"), t.lastIndexOf("ï¼š")
  );
  if (cut < 0) return;

  const safeChunk = t.slice(0, cut + 1).trim();
  if (!safeChunk) return;

  const buf = state.buffer.trim();
  if (isProbablyDuplicate(buf, safeChunk)) return;

  state.buffer += safeChunk + " ";
  lastBufferUpdateAt = Date.now();
  analyzeAndScheduleSend();
}

// ===== å®æ—¶é¢„è§ˆ =====
function updateLivePreview(){
  UI.liveText.innerHTML = `
    <span style="color:#2c3e50;font-weight:800;">${escapeHtml(state.buffer)}</span>
    <span style="color:#95a5a6;">${escapeHtml(state.interim)}</span>
  `;
  UI.liveText.scrollTop = UI.liveText.scrollHeight;
  UI.count.innerText = `ç¼“å†²åŒº: ${(state.buffer.length + state.interim.length)}å­—`;
}

// ===== æ®µè½/å‘åŒ…ç­–ç•¥ =====
function analyzeAndScheduleSend(){
  if (state.timer) clearTimeout(state.timer);
  if (forceFlushTimer) clearTimeout(forceFlushTimer);

  const text = state.buffer.trim();
  if (!text) return;

  const paragraphMode = UI.paragraphMode.checked;
  const lastChar = text.slice(-1);
  const isPunc = /[.?!ã€‚ï¼Ÿï¼]/.test(lastChar);

  if (text.length > CONFIG.maxCharsForce) {
    flushBuffer("å¼ºåˆ¶å‘é€(è¿‡é•¿)");
    return;
  }

  if (paragraphMode) {
    if (isPunc && text.length >= CONFIG.minCharsToSend) {
      state.timer = setTimeout(() => flushBuffer("æ®µè½å®Œæˆ(æ ‡ç‚¹)"), CONFIG.punctuationWait);
    } else {
      state.timer = setTimeout(() => flushBuffer("æ®µè½ç­‰å¾…(åœé¡¿)"), CONFIG.silenceThreshold);
    }
  } else {
    const fastMin = 60;
    state.timer = setTimeout(() => flushBuffer("å®æ—¶æ¨¡å¼(åœé¡¿)"), text.length >= fastMin ? 1200 : 1800);
  }

  forceFlushTimer = setTimeout(() => {
    if (!state.recording) return;
    const idle = Date.now() - lastBufferUpdateAt;
    if (idle >= CONFIG.forceFlushMs && state.buffer.trim().length > 0) {
      flushBuffer("æœ€å¤§æ—¶é—´çª—åˆ‡æ®µ");
    }
  }, CONFIG.forceFlushMs + 50);
}

// ===== å…¥é˜Ÿ =====
async function flushBuffer(reason){
  const text = state.buffer.trim();
  if (!text) return;

  const textToSend = text;
  state.buffer = "";
  state.interim = "";
  lastInterim = "";
  updateLivePreview();

  const blockId = "note-" + Date.now();
  const time = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});

  const noteData = { id:blockId, raw:textToSend, trans:"â³ æ­£åœ¨ç¿»è¯‘â€¦", time, status:"pending" };
  state.noteHistory.push(noteData);
  saveToLocal();

  renderNoteBlock(noteData);
  smartScroll();

  TRANSLATE.queue.push({
    seq: ++TRANSLATE.seq,
    blockId,
    raw: textToSend,
    topic: UI.topic.value || "é€šç”¨å­¦æœ¯",
    reason: reason || ""
  });

  runTranslateQueue();
}

// ===== é˜Ÿåˆ—ç¿»è¯‘ï¼ˆä¸²è¡Œï¼‰=====
async function runTranslateQueue(){
  if (TRANSLATE.running || TRANSLATE.pausedByAuth) return;
  TRANSLATE.running = true;

  while (TRANSLATE.queue.length && !TRANSLATE.pausedByAuth) {
    const job = TRANSLATE.queue.shift();
    await translateOne(job);
  }

  TRANSLATE.running = false;
  UI.status.innerHTML = state.recording
    ? `<span class="rec-dot"></span>æ­£åœ¨è†å¬è€å¸ˆå‘è¨€â€¦`
    : `âœ… å·²åœæ­¢ï¼ˆç¿»è¯‘å®Œæˆï¼‰`;
}

function buildContext(){
  return TRANSLATE.recentTranslations.slice(-TRANSLATE.maxRecent).join("\n");
}

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

// fetch è¶…æ—¶ä¿æŠ¤ï¼šé¿å…æŸä¸€æ¬¡è¯·æ±‚â€œæ°¸ä¹… pendingâ€æŠŠæ•´æ¡ç¿»è¯‘é˜Ÿåˆ—å¡æ­»
async function fetchWithTimeout(url, options, timeoutMs = 20000){
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    return await fetch(url, { ...options, signal: controller.signal });
  } finally {
    clearTimeout(timer);
  }
}

async function translateOne(job){
  // NOTE: å¿…é¡»è¶³å¤Ÿå¥å£®ï¼šä»»ä½•ä¸€ä¸ª DOM ç¼ºå¤±éƒ½ä¸åº”è®©æ•´æ¡ç¿»è¯‘é˜Ÿåˆ—å¡æ­»ã€‚
  const apiKey = ((UI.apiKey && typeof UI.apiKey.value === "string") ? UI.apiKey.value : "").trim();

  // authMode=browserï¼šåªæœ‰åœ¨â€œåŒæº/æœ¬åœ°åç«¯â€æˆ–ç›®æ ‡æ¥å£æ˜ç¡®å…è®¸ CORS æ—¶æ‰å¯èƒ½æˆåŠŸ
  // GitHub Pages åœºæ™¯æ¨è authMode=proxyï¼ˆCloudflare Worker / æœ¬åœ° Node ä»£ç†ï¼‰ï¼Œå‰ç«¯ä¸å¸¦ Authorization
  if (CONFIG.authMode === "browser") {
    if (!apiKey) {
      updateNote(job.blockId, "âš ï¸ ç¼ºå°‘ API Keyï¼ˆå½“å‰ä¸º browser æ¨¡å¼ï¼‰", true);
      TRANSLATE.pausedByAuth = true;
      return;
    }
    localStorage.setItem("ds_api_key", apiKey);
  }

  UI.status.innerText = `ğŸš€ ç¿»è¯‘ä¸­... (#${job.seq})`;

  const glossaryBlock = glossaryToPromptBlock();
  const ctx = buildContext();
  // æ—§ç‰ˆ UI æ²¡æœ‰ targetLang æ§ä»¶æ—¶ä¹Ÿè¦èƒ½è·‘ï¼ˆé»˜è®¤ä¸­æ–‡ï¼‰
  const targetLang = (UI.targetLang && typeof UI.targetLang.value === "string" && UI.targetLang.value.trim())
    ? UI.targetLang.value.trim()
    : "ä¸­æ–‡";

  // æ›´ç¨³çš„ç¿»è¯‘æç¤ºè¯ï¼šå¼ºè°ƒå¿ å®ã€æœ¯è¯­ä¼˜å…ˆã€ä¸è¦é¢å¤–è§£é‡Š
  const systemPrompt = [
    "ä½ æ˜¯ä¸€åä¸“ä¸šåŒå£°ä¼ è¯‘/å­—å¹•ç¿»è¯‘åŠ©æ‰‹ã€‚",
    "ç›®æ ‡ï¼šæŠŠè¾“å…¥å†…å®¹ç¿»è¯‘æˆç”¨æˆ·æŒ‡å®šè¯­è¨€ï¼Œä¿æŒåŸæ„ã€é€»è¾‘ã€è¯­æ°”ï¼›ä¸è¦æ·»åŠ è§£é‡Šã€ä¸è¦æ€»ç»“ã€ä¸è¦æ‰©å†™ã€‚",
    "ä¿ç•™ä¸“æœ‰åè¯ã€è¯¾ç¨‹æœ¯è¯­ã€æ•°å­—ã€åœ°åã€äººåï¼›é‡åˆ°ä¸ç¡®å®šçš„ä¸“åå¯éŸ³è¯‘å¹¶ä¿ç•™åŸæ–‡æ‹¬å·ã€‚",
    "å¦‚æœæœ‰æœ¯è¯­è¡¨ï¼Œä¼˜å…ˆä½¿ç”¨æœ¯è¯­è¡¨ç»™å‡ºçš„è¯‘æ³•ã€‚",
    "è¾“å‡ºåªåŒ…å«ç¿»è¯‘æ–‡æœ¬ï¼Œä¸è¦åŠ ä»»ä½•å‰åç¼€ã€‚",
    "å¯é€‚åº¦çœç•¥å£å¤´å¡«å……è¯ï¼ˆå—¯ã€å°±æ˜¯ã€ä½ çŸ¥é“ç­‰ï¼‰ï¼Œä½†ä¸å¾—çœç•¥å…³é”®ä¿¡æ¯ã€‚",
    "å¬ä¸æ¸…æˆ–è¯­ä¹‰ç¼ºå¤±æ—¶ç”¨ã€Œï¼ˆå¬ä¸æ¸…ï¼‰ã€æ ‡æ³¨ï¼Œä¸è¦ç¼–é€ ã€‚"
  ].join("\n");

  // æ‰‹åŠ¨é‡è¯‘ï¼ˆä¸¥æ ¼æ¨¡å¼ï¼‰ï¼šæ›´å¿ å®ã€ä¸çœç•¥ä¿¡æ¯
  const strictHint = job && job.strict ? "\n\nã€é‡è¯‘è¦æ±‚ã€‘è¯·æ›´å¿ å®é€å¥ç¿»è¯‘ï¼Œå°½é‡ä¿ç•™ä¿¡æ¯ï¼Œä¸è¦æ„è¯‘æ‰©å†™ï¼›ä¸ç¡®å®šå¤„æ ‡æ³¨ï¼ˆå¬ä¸æ¸…ï¼‰" : "";


  const userPrompt = [
    `ã€ç›®æ ‡è¯­è¨€ã€‘${targetLang}`,
    glossaryBlock ? `\nã€æœ¯è¯­è¡¨ã€‘\n${glossaryBlock}\n` : "",
    ctx ? `\nã€ä¸Šä¸‹æ–‡ï¼ˆä»…ä¾›ä¸€è‡´æ€§ï¼‰ã€‘\n${ctx}\n` : "",
    "\nã€éœ€è¦ç¿»è¯‘çš„åŸæ–‡ã€‘",
    job.raw,
    strictHint
  ].join("\n");

  const payload = {
    model: CONFIG.model,
    temperature: 0.15,
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: userPrompt }
    ]
  };

  const endpoint = (CONFIG.authMode === "browser") ? CONFIG.directUrl : CONFIG.url;

  const headers = { "Content-Type": "application/json" };
  if (CONFIG.authMode === "browser") headers["Authorization"] = `Bearer ${apiKey}`;

  // è½»é‡é‡è¯•ï¼šå¤„ç†ä¸´æ—¶ç½‘ç»œæ³¢åŠ¨/ä»£ç†å¶å‘æŠ–åŠ¨
  const maxAttempts = 3;
  let lastErr = null;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const resp = await fetchWithTimeout(endpoint, {
        method: "POST",
        headers,
        body: JSON.stringify(CONFIG.authMode === "proxy" ? { payload } : payload)
      }, CONFIG.requestTimeoutMs || 20000);

      // 401/403ï¼šKey é”™/æƒé™é—®é¢˜ â†’ æš‚åœé˜Ÿåˆ—
      if (resp.status === 401 || resp.status === 403) {
        TRANSLATE.pausedByAuth = true;
        const msg = `ğŸ”’ æˆæƒå¤±è´¥ï¼ˆHTTP ${resp.status}ï¼‰ã€‚å¦‚æœä½ åœ¨ GitHub Pages ä½¿ç”¨ï¼Œè¯·æ”¹ç”¨â€œproxy æ¨¡å¼â€ï¼ˆCloudflare Worker/æœ¬åœ°ä»£ç†ï¼‰è€Œä¸æ˜¯ corsproxyã€‚`;
        updateNote(job.blockId, msg, true);
        return;
      }

      const raw = await resp.text();
      let data = null;
      try { data = JSON.parse(raw); } catch(e) {}

      if (!resp.ok) {
        const hint = data?.error?.message || data?.message || raw.slice(0, 200);
        throw new Error(`HTTP ${resp.status}: ${hint}`);
      }

      // å…¼å®¹ä¸¤ç§è¿”å›ï¼š
      // - ç›´è¿ DeepSeekï¼š{choices:[{message:{content:"..."}}]}
      // - ä½ çš„ä»£ç†ï¼šå¯èƒ½ç›´æ¥é€ä¼ ç›¸åŒç»“æ„ï¼Œä¹Ÿå¯èƒ½è‡ªå®šä¹‰ï¼›è¿™é‡Œå°½é‡å…¼å®¹
      const translated =
        data?.choices?.[0]?.message?.content
        ?? data?.translation
        ?? (typeof data === "string" ? data : "")
        ?? "";

      const out = (translated || "").trim();
      if (!out) throw new Error("ç©ºå“åº”ï¼šç¿»è¯‘å†…å®¹ä¸ºç©ºï¼ˆå¯èƒ½æ˜¯ä»£ç†æœªæŒ‰é¢„æœŸè½¬å‘ï¼‰");

      // å†™å…¥ UI
      updateNote(job.blockId, out, false);

      // è®°å½•ä¸Šä¸‹æ–‡ï¼ˆç”¨äºä¸‹ä¸€æ®µä¸€è‡´æ€§ï¼‰
      TRANSLATE.recentTranslations.push(out);
      if (TRANSLATE.recentTranslations.length > TRANSLATE.maxRecent) {
        TRANSLATE.recentTranslations.splice(0, TRANSLATE.recentTranslations.length - TRANSLATE.maxRecent);
      }

      return; // âœ… æˆåŠŸå°±ç»“æŸ
    } catch (e) {
      lastErr = e;
      // æœ€åä¸€æ¬¡å¤±è´¥æ‰æ˜¾ç¤ºçº¢å­—
      if (attempt === maxAttempts) {
        updateNote(job.blockId, `ç¿»è¯‘å¤±è´¥ï¼š${String(e?.message || e)}`, true);
        return;
      }
      // æŒ‡æ•°é€€é¿
      await sleep(350 * attempt * attempt);
    }
  }

  // ç†è®ºä¸Šä¸ä¼šèµ°åˆ°è¿™
  updateNote(job.blockId, `ç¿»è¯‘å¤±è´¥ï¼š${String(lastErr?.message || lastErr)}`, true);
}


function mergeTermsToGlossary(pairs){
  const current = parseGlossary();
  const map = new Map(current.map(([k,v]) => [k.toLowerCase(), [k,v]]));

  let changed = false;
  for (const [k, v] of pairs) {
    const key = k.toLowerCase();
    if (!map.has(key)) {
      map.set(key, [k, v]);
      changed = true;
    }
  }
  if (!changed) return;

  const merged = Array.from(map.values())
    .sort((a,b) => a[0].localeCompare(b[0], "zh-CN"))
    .map(([k,v]) => `${k}=${v}`)
    .join("\n");

  UI.glossary.value = merged;
  localStorage.setItem(CONFIG.glossaryKey, merged);
}

// ===== æ¸²æŸ“ç¬”è®°ï¼ˆå¸¦å¤åˆ¶æŒ‰é’®ï¼‰=====
function renderNoteBlock(note){
  const html = `
    <div class="note-block" id="${note.id}">
      <div class="note-header">
        <span>ğŸ•’ ${escapeHtml(note.time)}</span>
        <span class="status-tag" style="color:#f39c12">è®¡ç®—ä¸­â€¦</span>
      </div>
      <div class="content-row">
        <div>
          <div class="text-origin" id="${note.id}-raw">${escapeHtml(note.raw)}</div>
          <div class="tool-bar">
            <button class="mini-btn" onclick="copyById('${note.id}-raw')">å¤åˆ¶åŸæ–‡</button>
          </div>
        </div>

        <div style="margin-top:6px;border-top:1px dashed #eee;padding-top:10px;">
          <div class="text-trans" id="${note.id}-trans">${escapeHtml(note.trans)}</div>
          <div class="tool-bar">
            <button class="mini-btn" onclick="copyById('${note.id}-trans')">å¤åˆ¶è¯‘æ–‡</button>
            <button class="mini-btn" onclick="retryTranslate(\'${note.id}\', false)">é‡æ–°ç¿»è¯‘</button>
            <button class="mini-btn" onclick="retryTranslate(\'${note.id}\', true)">ä¸¥æ ¼é‡è¯‘</button>
          </div>
        </div>
      </div>
    </div>
  `;
  UI.container.insertAdjacentHTML("beforeend", html);
  UI.welcome.style.display = "none";
}

function updateNote(blockId, text, isError){
  const block = document.getElementById(blockId);
  if (!block) return;

  const safe = escapeHtml(text).replace(/\*\*(.*?)\*\*/g, "<b>$1</b>");
  const transDiv = document.getElementById(blockId + "-trans");
  transDiv.innerHTML = isError ? `<span style="color:red">${safe}</span>` : safe;

  const tag = block.querySelector(".status-tag");
  tag.innerText = isError ? "é”™è¯¯" : "å·²ç¿»è¯‘";
  tag.style.color = isError ? "red" : "var(--success)";

  const n = state.noteHistory.find(x => x.id === blockId);
  if (n) {
    n.trans = text;
    n.status = isError ? "error" : "done";
  }

  smartScroll();
}

// ===== å¤åˆ¶ï¼šä¼˜å…ˆ clipboardï¼Œå¤±è´¥å°± execCommand é™çº§ =====
async function copyById(id){
  const el = document.getElementById(id);
  if (!el) return;
  const text = el.innerText || "";

  try{
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(text);
    } else {
      fallbackCopyText(text);
    }
    flashCopy(el);
  } catch {
    fallbackCopyText(text);
    flashCopy(el);
  }
}

// ===== æ‰‹åŠ¨é‡è¯‘ï¼ˆæ®µè½æŒ‰é’®ï¼‰=====
function retryTranslate(blockId, strict){
  // æ‰¾åˆ°å¯¹åº”æ®µè½
  const note = state.noteHistory.find(n => n.id === blockId);
  if (!note) return;

  // ç«‹å³æ›´æ–° UI çŠ¶æ€
  const block = document.getElementById(blockId);
  if (block){
    const tag = block.querySelector(".status-tag");
    if (tag){
      tag.innerText = "è®¡ç®—ä¸­â€¦";
      tag.style.color = "#f39c12";
    }
  }
  const transDiv = document.getElementById(blockId + "-trans");
  if (transDiv) transDiv.innerHTML = escapeHtml("â³ æ­£åœ¨ç¿»è¯‘â€¦");

  // å…¥é˜Ÿé‡æ–°ç¿»è¯‘ï¼ˆç»•è¿‡å»é‡é€»è¾‘ï¼‰
  TRANSLATE.queue.push({
    seq: ++TRANSLATE.seq,
    blockId,
    raw: (note.raw || "").trim(),
    topic: UI.topic && UI.topic.value ? UI.topic.value : "é€šç”¨å­¦æœ¯",
    reason: strict ? "manual-retry-strict" : "manual-retry",
    strict: !!strict
  });

  // åŒæ­¥æ›´æ–°ç¼“å­˜ï¼Œé¿å…åˆ·æ–°åä¸¢çŠ¶æ€
  note.trans = "â³ æ­£åœ¨ç¿»è¯‘â€¦";
  saveToLocal();

  runTranslateQueue();
}

function fallbackCopyText(text){
  const ta = document.createElement("textarea");
  ta.value = text;
  ta.style.position = "fixed";
  ta.style.left = "-9999px";
  ta.style.top = "-9999px";
  document.body.appendChild(ta);
  ta.focus();
  ta.select();
  try { document.execCommand("copy"); } catch {}
  document.body.removeChild(ta);
}

function flashCopy(el){
  const old = el.style.background;
  el.style.background = "#dff9fb";
  setTimeout(() => el.style.background = old, 220);
}

// ===== æŒä¹…åŒ– =====
function saveToLocal(){
  localStorage.setItem(CONFIG.localStorageKey, JSON.stringify(state.noteHistory));
}
function restoreSession(){
  const backup = localStorage.getItem(CONFIG.localStorageKey);
  if (!backup) return;

  try{
    const data = JSON.parse(backup);
    if (!Array.isArray(data)) return;

    state.noteHistory = data;
    UI.container.innerHTML = "";
    state.noteHistory.forEach(note => {
      renderNoteBlock(note);
      if (note.trans === "â³ æ­£åœ¨ç¿»è¯‘â€¦" || note.status === "pending") {
        updateNote(note.id, "âš ï¸ æ¢å¤çš„æ•°æ®ï¼šåŸæ–‡å·²ä¿å­˜ï¼Œä½†æœªå®Œæˆç¿»è¯‘ã€‚", true);
      } else {
        updateNote(note.id, note.trans, false);
      }
    });

    UI.restoreBar.style.display = "none";
    UI.welcome.style.display = "none";
    scrollToBottomForce();
  } catch {}
}

function clearSession(){
  if (!confirm("ç¡®å®šæ¸…ç©ºæ‰€æœ‰ç¬”è®°å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚")) return;
  state.noteHistory = [];
  TRANSLATE.recentTranslations = [];
  TRANSLATE.queue = [];
  TRANSLATE.pausedByAuth = false;

  localStorage.removeItem(CONFIG.localStorageKey);
  UI.container.innerHTML = "";
  UI.welcome.style.display = "block";
  UI.restoreBar.style.display = "none";
}

// ===== æ§åˆ¶ï¼šä¸Šè¯¾/ä¸‹è¯¾ =====
async function startSession(){
  if (!UI.apiKey.value.trim()) { alert("è¯·å…ˆè¾“å…¥ DeepSeek API Key"); return; }

  // å…ˆæ‹¿ä¸€æ¬¡éº¦å…‹é£æƒé™ï¼ˆé¿å…åå¤å¼¹ï¼‰
  const ok = await ensureMicPermission();
  if (!ok) return;

  // wakelockï¼ˆå°½é‡åˆ«ç¡çœ ï¼‰
  await enableWakeLock();

  if (!state.recognition) initSpeech();
  updateUiState(true);
  UI.bottomBar.classList.remove("hidden");

  try { state.recognition.start(); } catch {}
}

async function stopSession(){
  state.recording = false;

  if (state.timer) clearTimeout(state.timer);
  if (interimCommitTimer) clearTimeout(interimCommitTimer);

  try { state.recognition && state.recognition.stop(); } catch {}

  if (state.buffer.trim()) await flushBuffer("åœæ­¢ä¼šè¯æ”¶å°¾");

  UI.status.innerText = "ğŸ§¹ æ­£åœ¨æ”¶å°¾ç¿»è¯‘â€¦";
  while (TRANSLATE.running || TRANSLATE.queue.length) {
    await new Promise(r => setTimeout(r, 120));
  }

  disableWakeLock();

  updateUiState(false);
  UI.status.innerText = "âœ… å·²åœæ­¢ï¼ˆç¿»è¯‘å®Œæˆï¼‰";
}

function updateUiState(isRecording){
  UI.btnStart.style.display = isRecording ? "none" : "flex";
  UI.btnStop.style.display = isRecording ? "flex" : "none";

  if (isRecording) {
    UI.bottomBar.classList.remove("hidden");
    UI.welcome.style.display = "none";
  } else {
    UI.bottomBar.classList.add("hidden");
  }
}

// ===== å¯¼å‡º Word =====
function exportWord(){
  const topic = UI.topic.value || "æ³•è¯­è¯¾å ‚ç¬”è®°";
  const date = new Date().toLocaleString();

  let doc = `
    <html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word'>
    <head><meta charset='utf-8'><title>${escapeHtml(topic)}</title></head>
    <body style="font-family:'Microsoft YaHei',sans-serif">
      <h1 style="text-align:center;color:#2c3e50;">${escapeHtml(topic)}</h1>
      <p style="text-align:center;color:#7f8c8d;font-size:12px;">ç”Ÿæˆæ—¶é—´: ${escapeHtml(date)}</p>
      <hr/>
  `;

  state.noteHistory.forEach(note => {
    doc += `
      <div style="margin-bottom:18px;border:1px solid #eee;padding:12px;border-radius:8px;">
        <p style="margin:0 0 6px 0;font-size:10px;color:#999;">${escapeHtml(note.time || "")}</p>
        <p style="font-family:Georgia;color:#555;font-style:italic;margin:5px 0;white-space:pre-wrap;">${escapeHtml(note.raw || "")}</p>
        <p style="font-weight:bold;color:#000;margin:8px 0;white-space:pre-wrap;line-height:1.7;">${escapeHtml(note.trans || "")}</p>
      </div>
    `;
  });

  doc += `</body></html>`;

  const blob = new Blob([doc], { type: "application/msword" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = `${topic}_${Date.now()}.doc`;
  link.click();
}

// ===== XSS é˜²æŠ¤ =====
function escapeHtml(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
</script>
</body>
</html>
